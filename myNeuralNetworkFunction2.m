function [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 13-May-2023 15:42:12.
%
% [Y,Xf,Af] = myNeuralNetworkFunction(X,Xi,~) takes these arguments:
%
%   X = 2xTS cell, 2 inputs over TS timesteps
%   Each X{1,ts} = Qx2 matrix, input #1 at timestep ts.
%   Each X{2,ts} = Qx1 matrix, input #2 at timestep ts.
%
%   Xi = 2x2 cell 2, initial 2 input delay states.
%   Each Xi{1,ts} = 2xQ matrix, initial states for input #1.
%   Each Xi{2,ts} = 1xQ matrix, initial states for input #2.
%
%   Ai = 2x0 cell 2, initial 2 layer delay states.
%   Each Ai{1,ts} = 10xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 1xQ matrix, initial states for layer #2.
%
% and returns:
%   Y = 1xTS cell of 2 outputs over TS timesteps.
%   Each Y{1,ts} = Qx1 matrix, output #1 at timestep ts.
%
%   Xf = 2x2 cell 2, final 2 input delay states.
%   Each Xf{1,ts} = 2xQ matrix, final states for input #1.
%   Each Xf{2,ts} = 1xQ matrix, final states for input #2.
%
%   Af = 2x0 cell 2, final 0 layer delay states.
%   Each Af{1ts} = 10xQ matrix, final states for layer #1.
%   Each Af{2ts} = 1xQ matrix, final states for layer #2.
%
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.keep = 1;
x1_step2.xoffset = 1;
x1_step2.gain = 0.000557258289217052;
x1_step2.ymin = -1;

% Input 2
x2_step1.xoffset = 0.000859603441475251;
x2_step1.gain = 3.555074689186;
x2_step1.ymin = -1;

% Layer 1
b1 = [2.3511664661407478683;-1.6294222411369378989;0.93180200839788995815;-0.74442309974606390988;0.73242361855631998857;0.12232318416419549201;0.8212894069978722289;-1.482031467729065799;1.7799796571536750101;2.5874241848758345874];
IW1_1 = [-1.4195610991595999373 1.23025323369796169;0.3918090880608779969 1.9497704014867935918;-0.75036668158177943777 0.078738211874796223966;1.684053268889409205 -1.0269296772592320099;-1.096695324400149163 -1.0659283705038287149;1.2494703367566950547 1.2633946492568099984;0.70551717615141906759 1.0550364776488341256;-1.3984309044557134971 -1.420076972188366593;1.8568378240286635972 0.82708866022175264732;1.9461922187903710757 0.7720507628285320223];
IW1_2 = [-0.51911684843546390677 1.5839485081016086987;-0.045856090922963402279 -1.2194850481024712696;-1.2899818129648177312 1.6482526100844243633;-0.00029549819813356965935 1.5705358574254455473;-1.8322193718171044807 -0.22608081286110162655;0.075067755748436756913 1.5599709199693740924;-1.1621287339295713892 1.3577326447863071746;-1.6352826367342920832 -0.19872224270953198211;0.069243989037349393256 1.1809365237258917514;0.62204564524656480451 0.94954517643313574027];

% Layer 2
b2 = -0.087531825876862007219;
LW2_1 = [0.62821102516895321877 0.00021991834645147123476 0.49090548437136583004 0.43194084342167626822 -0.42991903917988510964 -0.50932056464560671039 -0.10946540960817713328 -0.73481971129368606199 -0.59007223688252785632 -0.36774382598166088787];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 3.555074689186;
y1_step1.xoffset = 0.000859603441475251;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX
    X = {X};
end
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},1); % samples/series
elseif ~isempty(Xi)
    Q = size(Xi{1},2);
else
    Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,3);
for ts=1:2
    temp = removeconstantrows_apply(Xi{1,ts},x1_step1);
    Xd1{ts} = mapminmax_apply(temp,x1_step2);
end

% Input 2 Delay States
Xd2 = cell(1,3);
for ts=1:2
    Xd2{ts} = mapminmax_apply(Xi{2,ts},x2_step1);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Rotating delay state position
    xdts = mod(ts+1,3)+1;

    % Input 1
    X{1,ts} = X{1,ts}';
    temp = removeconstantrows_apply(X{1,ts},x1_step1);
    Xd1{xdts} = mapminmax_apply(temp,x1_step2);

    % Input 2
    X{2,ts} = X{2,ts}';
    Xd2{xdts} = mapminmax_apply(X{2,ts},x2_step1);

    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1 2]-1,3)+1});
    tapdelay2 = cat(1,Xd2{mod(xdts-[1 2]-1,3)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1 + IW1_2*tapdelay2);

    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;

    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1);
    Y{1,ts} = Y{1,ts}';
end

% Final Delay States
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(2,0);

% Format Output Arguments
if ~isCellX
    Y = cell2mat(Y);
end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Remove Constants Input Processing Function
function y = removeconstantrows_apply(x,settings)
y = x(settings.keep,:);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
