function [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2)
%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 13-May-2023 15:38:33.
%
% [y1,xf1,xf2] = myNeuralNetworkFunction(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 2xTS matrix, input #1
%   x2 = 1xTS matrix, input #2
%   xi1 = 2x2 matrix, initial 2 delay states for input #1.
%   xi2 = 1x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 1xTS matrix, output #1
%   xf1 = 2x2 matrix, final 2 delay states for input #1.
%   xf2 = 1x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.keep = 1;
x1_step2.xoffset = 1;
x1_step2.gain = 0.000557258289217052;
x1_step2.ymin = -1;

% Input 2
x2_step1.xoffset = 0.000859603441475251;
x2_step1.gain = 3.555074689186;
x2_step1.ymin = -1;

% Layer 1
b1 = [2.3511664661407478683;-1.6294222411369378989;0.93180200839788995815;-0.74442309974606390988;0.73242361855631998857;0.12232318416419549201;0.8212894069978722289;-1.482031467729065799;1.7799796571536750101;2.5874241848758345874];
IW1_1 = [-1.4195610991595999373 1.23025323369796169;0.3918090880608779969 1.9497704014867935918;-0.75036668158177943777 0.078738211874796223966;1.684053268889409205 -1.0269296772592320099;-1.096695324400149163 -1.0659283705038287149;1.2494703367566950547 1.2633946492568099984;0.70551717615141906759 1.0550364776488341256;-1.3984309044557134971 -1.420076972188366593;1.8568378240286635972 0.82708866022175264732;1.9461922187903710757 0.7720507628285320223];
IW1_2 = [-0.51911684843546390677 1.5839485081016086987;-0.045856090922963402279 -1.2194850481024712696;-1.2899818129648177312 1.6482526100844243633;-0.00029549819813356965935 1.5705358574254455473;-1.8322193718171044807 -0.22608081286110162655;0.075067755748436756913 1.5599709199693740924;-1.1621287339295713892 1.3577326447863071746;-1.6352826367342920832 -0.19872224270953198211;0.069243989037349393256 1.1809365237258917514;0.62204564524656480451 0.94954517643313574027];

% Layer 2
b2 = -0.087531825876862007219;
LW2_1 = [0.62821102516895321877 0.00021991834645147123476 0.49090548437136583004 0.43194084342167626822 -0.42991903917988510964 -0.50932056464560671039 -0.10946540960817713328 -0.73481971129368606199 -0.59007223688252785632 -0.36774382598166088787];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 3.555074689186;
y1_step1.xoffset = 0.000859603441475251;

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = removeconstantrows_apply(xi1,x1_step1);
xd1 = mapminmax_apply(xd1,x1_step2);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(1,1)];

% Allocate Outputs
y1 = zeros(1,TS);

% Time loop
for ts=1:TS

    % Rotating delay state position
    xdts = mod(ts+1,3)+1;

    % Input 1
    temp = removeconstantrows_apply(x1(:,ts),x1_step1);
    xd1(:,xdts) = mapminmax_apply(temp,x1_step2);

    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);

    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),2,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);

    % Layer 2
    a2 = b2 + LW2_1*a1;

    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Remove Constants Input Processing Function
function y = removeconstantrows_apply(x,settings)
y = x(settings.keep,:);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
